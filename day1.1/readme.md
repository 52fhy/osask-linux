# 第一天

当然，老实说这也算不上第一天，在一个星期以前我已经把这本书翻了一遍，在忙完了手中的事情后，也打算认真的实验一遍。

这本书虽然名字叫着30天自制操作系统，但事实上在这30天之前你需要有一些知识的沉淀，如果没有的话，或许要得多一段时间吧。

我也把书中的光盘文件上传到了github，链接：[github.com/imangoa/os](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fimangoa%2Fos)。嗯，如果要看书的话，我建议到微信读书里，用不完的体验卡，哈哈。

## 编写hello world

书中要完成的第一个任务就是在打开电源时显示 hello world，就像我们以前学习一门新语言一样。

而在这本书地第一章，提供了三种方式去完成这个。当然，这三种方式也是殊途同归。

第一种是通过编辑二进制的方式，按照作者给的二进制值输入，最后把文件后缀改为.img。当然，作者也没打算我们真的这么去做，以这种诙谐的手法，可能是旨在告诉读者一切程序都由二进制构成。

第一种太长了，就不写下来了，放个截图。感兴趣的伙伴可以用二进制编辑器打开镜像文件直接查看。

![image-20220913100449531](../images/image-20220913100410797.png)

Linux下使用hexdump查看二进制内容：
``` bash
hexdump ../day2.1/helloos.img 

0000000 4eeb 4890 4c45 4f4c 5049 004c 0102 0001
0000010 e002 4000 f00b 0009 0012 0002 0000 0000
0000020 0b40 0000 0000 ff29 ffff 48ff 4c45 4f4c
0000030 4f2d 2053 2020 4146 3154 2032 2020 0000
0000040 0000 0000 0000 0000 0000 0000 0000 0000
0000050 00b8 8e00 bcd0 7c00 d88e c08e 74be 8a7c
0000060 8304 01c6 003c 0974 0eb4 0fbb cd00 eb10
0000070 f4ee fdeb 0a0a 6568 6c6c 2c6f 7720 726f
0000080 646c 000a 0000 0000 0000 0000 0000 0000
0000090 0000 0000 0000 0000 0000 0000 0000 0000
*
00001f0 0000 0000 0000 0000 0000 0000 0000 aa55
0000200 fff0 00ff 0000 0000 0000 0000 0000 0000
0000210 0000 0000 0000 0000 0000 0000 0000 0000
*
0001400 fff0 00ff 0000 0000 0000 0000 0000 0000
0001410 0000 0000 0000 0000 0000 0000 0000 0000
*
0168000
```

第二种使用的是汇编，不过是使用汇编的RESB标识符和DB标识符进行写二进制值，RESB符填充了为00的二进制位。本质上与第一种方式并没有区别。

``` assembly
DB	0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f
DB	0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00
DB	0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00
DB	0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00
DB	0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff
DB	0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4f
DB	0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41
DB	0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00
RESB	16
DB	0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
DB	0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
DB	0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
DB	0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
DB	0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65
DB	0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72
DB	0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00
RESB	368
DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa
DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB	4600
DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB	1469432 
```

第三种方式也是通过汇编，与第一种和第二种并无本质区别。其实也就是第二种方式上把代码整理的更符合人类编码方式，知其然，知其所以然。第三种就是知其所以然吧。老规矩，上代码。

``` assembly
; hello-os
; TAB=4

; 以下这段是标准FAT12格式软盘专用代码
DB		0xeb, 0x4e, 0x90
DB		"HELLOIPL"		; 启动区的名称可以是任意的字符串(8字节)
DW		512				; 每个扇区的大小（必须是512字节）
DB		1				; 簇的大小（必须为1扇区）
DW		1				; FAT的起始位置（一般从第一个扇区开始）
DB		2				; FAT的个数（必须为2）
DW		224				; 根目录的大小（一般设成224项）
DW		2880			; 该磁盘的大小（必须是2880扇区）
DB		0xf0			; 磁盘的种类（必须是0xf0）
DW		9				; FAT的长度（必须是9扇区）
DW		18				; 1个磁道有几个扇区（必须是18）
DW		2				; 磁头数（必须是2）
DD		0				; 不使用分区，必须是0
DD		2880			; 重写一次磁盘的大小
DB		0,0,0x29		; 意义不明，固定
DD		0xffffffff		; （可能是）卷标号码
DB		"HELLO-OS   "	; 磁盘的名称（11字节）
DB		"FAT12   "		; 磁盘格式名称（8字节）
RESB	18				; 先空出18字节

; 程序本体
DB		0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
DB		0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
DB		0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
DB		0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
DB		0xee, 0xf4, 0xeb, 0xfd

; 信息显示部分
DB		0x0a, 0x0a		; 两个换行
DB		"hello, world"
DB		0x0a			; 换行
DB		0

RESB	0x1fe-$			; 填写0xoo，直到0x001fe

DB		0x55, 0xaa

; 以下是启动区以外部分的输出
DB		0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB	4600
DB		0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB	1469432
```

**当然，虽然是三种方法，但其实本质都和第一种是一样的。都只是在排列二进制位。**


知识点：

- DW指令和DD指令，它们分别是“define word”和“define double-word”的缩写，是DB指令的“堂兄弟”。word的本意是“单词”，但在计算机汇编语言的世界里，word指的是“16位”的意思，也就是2个字节。“double-word”是“32位”的意思，也就是4个字节
- RESB是预留指定字节,nasm默认填充0(测试发现)
- 软盘第一个的扇区称为启动区。那么什么是扇区呢？计算机读写软盘的时候，并不是一个字节一个字节地读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就称为一个扇区。一张软盘的空间共有`1440KB`，也就是`1474560`字节，除以512得`2880`，这也就是说一张软盘共有`2880`个扇区。
- 那为什么第一个扇区称为启动区呢？那是因为计算机首先从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。如果这最后2个字节不是0x55AA，计算机会认为这张盘上没有所需的启动程序，就会报一个不能启动的错误。也许有人会问为什么一定是`0x55 AA`呢？那是当初的设计者随便定的，笔者也没法解释。如果计算机确认了第一个扇区的最后两个字节正好是0x55 AA，那它就认为这个扇区的开头是启动程序，并开始执行这个程序。
- `RESB 0x1fe-$`：这个美元符号是一个变量，可以告诉我们这一行现在的字节数。在这个程序里，我们已经在前面输出了132字节，所以这里的`$`就是132。因此nask先用0x1fe减去132，得出378这一结果，然后连续输出378个字节的0x00。使用nasm汇编器必须使用`0x1fe-($-$$)`代替。`$$`表示一个节（一段代码）的开始处被汇编后的地址。

## 运行hello world

很巧的是运行也有三种方法，第一种是在QEMU仿真器上运行，第二种是可以通过在vmware上面的软盘挂载运行，第三种是可以通过把img写入到U盘上，插入到真机上u盘启动运行。QEMU上运行会比较简单，而在真机上运行成就感或许会大。**所以，我选在VMware上运行，哈哈！**

放一波截图吧，hh

VMware运行



![VMware运行](../images/171366424239c735~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



QEMU运行

``` bash
qemu-system-i386 -drive file=myos.img,if=floppy
```

![QEMU运行](../images/1713662586fb0fa1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



**一波操作下来，第一天也就完成了！至于怎么在VMware上运行和真机上运行，可以百度搜索一下。我就不做教程的搬运工了**