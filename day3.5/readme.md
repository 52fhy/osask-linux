添加了haribote.nas文件，修改了makefile
makefile的步骤：
1.创建myos.img（和前面几次一样）
2.将haribote.nas编译为haribote.bin
3.挂载myos.img
4.复制haribote.bin到myos.img上
5.卸载myos.img

运行步骤:
make clean
make
sudo make copy
make run

用16进制编辑器hexedit查看：
hexedit myos.img
发现在地址为0000:2600的地方有数据了！成功!

Attention!
1.hexedit需要下载并安装：`sudo yum install hexedit -y`
2.`sudo make copy`这一步是必须的，因为要拷贝，同时需要sudo权限
3.另一个有数据的地址为0000:4400,发现和书上不一样。

``` bash
$ hexdump myos.img

0000000 3ceb 6390 7268 7369 7a5f 007a 0102 0001
0000010 e002 4000 f00b 0009 0012 0002 0000 0000
0000020 0b40 0000 0000 ff29 ffff 4dff 2079 6946
0000030 7372 2074 534f 4146 3154 2032 2020 00b8
0000040 8e00 8ed0 8ed8 bcc0 7c00 b5be e87c 0050
0000050 20b8 8e08 b5c0 b600 b100 be02 0000 02b4
0000060 01b0 00bb b200 cd00 7313 8312 01c6 fe83
0000070 0f05 b683 b400 b200 cd00 eb13 8ce1 83c0
0000080 20c0 c08e c180 8001 12f9 cf76 01b1 c680
0000090 8001 02fe c572 00b6 c580 8001 0afd bb72
00000a0 048a c683 3c01 7400 b409 bb0e 000a 10cd
00000b0 eeeb ebf4 0afd 3d0a 3d3d 3d3d 3d3d 3d3d
00000c0 3d3d 3d3d 0d0a 694e 6563 6420 7961 7e20
00000d0 7e7e 0d0a 6854 7369 6920 2073 796d 6620
00000e0 7269 7473 3020 0a53 630d 706f 7279 6769
00000f0 7468 4720 4c50 0d0a 5541 4854 524f 203a
0000100 6843 6972 5a73 0a5a 620d 6f6c 3a67 7468
0000110 7074 2f3a 632f 7268 7369 7a7a 732e 6e69
0000120 6161 7070 632e 6d6f 0d0a 0a00 580a 5858
0000130 5858 5858 5858 5858 0d0a 7265 6f72 2072
0000140 636f 7563 6572 0a64 000d 0000 0000 0000
0000150 0000 0000 0000 0000 0000 0000 0000 0000
*
00001f0 0000 0000 0000 0000 0000 0000 0000 aa55
0000200 0000 0000 fff0 0000 0000 0000 0000 0000
0000210 0000 0000 0000 0000 0000 0000 0000 0000
*
0001400 0000 0000 fff0 0000 0000 0000 0000 0000
0001410 0000 0000 0000 0000 0000 0000 0000 0000
*
0002600 6841 6100 7200 6900 6200 0f00 4200 006f
0002610 0074 0065 002e 0062 0069 0000 006e 0000
0002620 4148 4952 4f42 4554 4942 204e 0400 2668
0002630 552f 552f 0000 2668 552f 0003 0003 0000
0002640 0000 0000 0000 0000 0000 0000 0000 0000
*
0004400 ebf4 00fd 0000 0000 0000 0000 0000 0000
0004410 0000 0000 0000 0000 0000 0000 0000 0000
*
0168000
```


网上查过别人的帖子，基本上都是4400.估计是《30天》使用的工具和我们不太相同，我们这个4400经过考证应该是正确的。原因如下：

查看了微软的硬件白皮书（fatgen.doc），发现这个0x4400是可以计算出来的：
第一个公式：
RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec – 1)) / BPB_BytsPerSec;
这里需要注意，要round up取整。
第二个公式：
If(BPB_FATSz16 != 0)
	FATSz = BPB_FATSz16;
Else
	FATSz = BPB_FATSz32;
FirstDataSector = BPB_ResvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors;
预先设定的值中，BPB_FATSx16等于9，BPB_ResvdSecCnt为1， BPB_NumFATs为2， RootDirSectors上面计算得到是15，那么：
				FirstData=34
那么，34*512，也就是4400H那里了（4400H/200H=22H=34, 200H就是512k）


这里还有一个问题，就是在计算RootDirSectors的时候，感觉分子上的（512-1）没有什么用处。网上有人这样解释：
“"字节对齐作用",解释比较简单和牵强,不过你这句话提醒了我,我想微软的这个公式是同时用于计算FAT16和FAT12用的,
对于FAT16本身"(BPB_BytsPerSec – 1)/BPB_BytsPerSec"是没必要的,而对于FAT12由于它每个表项是1.5个字节,如果
应用不当的话有可能会造成"跨越扇区边界"的问题,故而保留了1个扇区,不知这样认识对不对,请朋友们继续发表看法. ”（ref：http://bbs.eeworld.com.cn/thread-131851-1-1.html）
